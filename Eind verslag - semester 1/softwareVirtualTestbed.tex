{\em Auteur: Bram Vandendriessche}


\noindent
Voor de simulator is geprobeerd om zo modulair mogelijk te werken, zodat nieuwe opstellingen of constraints gemakkelijk kunnen worden toegevoegd zonder dat dit voor problemen zou zorgen in de bestaande structuur. De klasse \textit{World} staat centraal in de simulator. Zij bevat alle basiselementen voor zowel het fysische als van het 3D-gedeelte van de wereld. Het fysische aspect wordt behandeld door de klasse \textit{Physics}. %todo verwijzen naar algoritmes, extra uitleg?
\\

\noindent
World is ge\"implementeerd als een subklasse van GLCanvas en legt de basis voor de 3D-weergave van de verschillende opstellingen. 
De klasse houdt bij welke WorldObjects ze bevat (Spheres, SimulationDrones, ObstacleSpheres) en implementeert enkele belangrijke functies voor de 3D-visualisatie ervan. De initialisatie van de wereld gebeurt door \texttt{init()}. De functie \texttt{draw()} roept van elk worldObject dat de wereld bevat de \texttt{draw()}-functie van dat object op. De \texttt{display()}-functie maakt meerdere keren gebruik van \texttt{draw()} om de wereld zowel naar het venster van de GUI te renderen als naar de \textit{framebuffer objects} die dienen voor het offscreen renderen (voor \texttt{takeimage()}).\\
Bovendien bevat World ook een abstracte methode \texttt{setup()}. Deze kan naar wens ge\"implementeerd worden door elke subklasse, zodat per mijlpaal een specifieke opstelling kan worden vastgelegd. Voor Milestone 1.1 is dit bijvoorbeeld enkel een rode bol en een drone (en enkele camera's), voor een wereld die vanuit een invoerbestand wordt opgebouwd met behulp van de parser bestaat ParserWorld, waarbij de setup()-functie gebruik maakt van de geparste waarden.\\
\\
Uiteraard is er niets aan een 3D-wereld indien hij niet bekeken kan worden. De klasse GeneralCamera werd ingevoerd om te kunnen werken met het concept van een camera, die een positie en kijkrichting krijgt. Zulke camera\'s kunnen dan op verschillende punten geplaatst worden (vastgelegd in de \texttt{setup} van de wereld), zodat de gebruiker de voortgang van de drone goed kan volgen. Een uitbreiding op dit concept is de DroneCamera, die zich voor zijn positie en ori\"entatie op de drone (waartoe hij behoort) zal baseren. Dit laatste type kan gebruikt worden voor de ``ogen'' van de drone en deze klasse implementeert de \textit{Camera}-interface van de API voor de verbinding van Autopilot en Testbed.\\
Deze rol vult SimulationDrone in voor de \textit{Drone}-interface. Deze klasse stelt de drone voor die in de simulator voorgesteld wordt als een blauwe balk. 

